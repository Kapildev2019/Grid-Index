# -*- coding: utf-8 -*-

"""
/***************************************************************************
 gridindex
                                 A QGIS plugin
 This plugin generates a grid of rectangular polygons for map book page indexing.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-06-07
        copyright            : (C) 2025 by Kapildev Adhikari
        email                : kapildevadk@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Kapildev Adhikari'
__date__ = '2025-06-07'
__copyright__ = '(C) 2025 by Kapildev Adhikari'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import math
from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterMapLayer,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterDistance,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterNumber,
                       QgsRectangle,
                       QgsGeometry,
                       QgsFeature,
                       QgsField,
                       QgsFields,
                       QgsWkbTypes,
                       QgsSpatialIndex,
                       QgsProject,
                       QgsProcessingException,
                       QgsFeatureRequest,
                       QgsVectorLayer,
                       QgsUnitTypes,
                       QgsCoordinateReferenceSystem,
                       QgsCoordinateTransform)
from qgis.PyQt.QtGui import QIcon
import os


class gridindexAlgorithm(QgsProcessingAlgorithm):
    """
    This algorithm creates a grid index with advanced labeling and ordering options.
    """

    INPUT_LAYER = 'INPUT_LAYER'
    CELL_WIDTH = 'CELL_WIDTH'
    CELL_HEIGHT = 'CELL_HEIGHT'
    USE_ABSOLUTE_NAMING = 'USE_ABSOLUTE_NAMING'
    LABEL_ORIGIN = 'LABEL_ORIGIN'
    NUM_ROWS = 'NUM_ROWS'
    NUM_COLS = 'NUM_COLS'
    START_PAGE = 'START_PAGE'
    OUTPUT = 'OUTPUT'

    def initAlgorithm(self, config=None):
        """Define the parameters for the tool."""
        
        self.addParameter(
            QgsProcessingParameterMapLayer(
                self.INPUT_LAYER, self.tr('Intersection Layer'),
                [QgsProcessing.TypeVector, QgsProcessing.TypeRaster]
            )
        )
        
        self.addParameter(
            QgsProcessingParameterDistance(
                self.CELL_WIDTH, self.tr('Grid Cell Width'),
                parentParameterName=self.INPUT_LAYER, defaultValue=500.0, optional=False
            )
        )
        
        self.addParameter(
            QgsProcessingParameterDistance(
                self.CELL_HEIGHT, self.tr('Grid Cell Height'),
                parentParameterName=self.INPUT_LAYER, defaultValue=500.0, optional=False
            )
        )

        self.addParameter(
            QgsProcessingParameterBoolean(
                self.USE_ABSOLUTE_NAMING,
                self.tr('Use absolute grid position for Page Names'),
                defaultValue=False
            )
        )
        self.parameterDefinition(self.USE_ABSOLUTE_NAMING).setHelp(
            self.tr("If checked, names are based on the overall grid column (e.g., C5). If unchecked, they are numbered sequentially within each row (e.g., C1, C2...).")
        )
        
        self.addParameter(
            QgsProcessingParameterEnum(
                self.LABEL_ORIGIN,
                self.tr('Labeling starts from'),
                options=['Top-Left', 'Top-Right', 'Bottom-Left', 'Bottom-Right'],
                defaultValue=0
            )
        )
        self.parameterDefinition(self.LABEL_ORIGIN).setHelp(
            self.tr("Controls which corner of the grid both the PageNumber and PageName sequences begin from.")
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.NUM_ROWS, self.tr('Number of rows (optional override)'),
                QgsProcessingParameterNumber.Integer, optional=True, defaultValue=0 
            )
        )
        
        self.addParameter(
            QgsProcessingParameterNumber(
                self.NUM_COLS, self.tr('Number of columns (optional override)'),
                QgsProcessingParameterNumber.Integer, optional=True, defaultValue=0 
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.START_PAGE, self.tr('Starting page number'),
                QgsProcessingParameterNumber.Integer, optional=True, defaultValue=1
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(self.OUTPUT, self.tr('Output Grid Index'))
        )
    
    def processAlgorithm(self, parameters, context, feedback):
        source = self.parameterAsLayer(parameters, self.INPUT_LAYER, context)
        if source is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT_LAYER))
            
        use_absolute_naming = self.parameterAsBoolean(parameters, self.USE_ABSOLUTE_NAMING, context)
        label_origin_index = self.parameterAsEnum(parameters, self.LABEL_ORIGIN, context)
        num_rows_override = self.parameterAsInt(parameters, self.NUM_ROWS, context)
        num_cols_override = self.parameterAsInt(parameters, self.NUM_COLS, context)
        start_page = self.parameterAsInt(parameters, self.START_PAGE, context)

        source_crs = source.crs()
        is_geographic = source_crs.isGeographic()
        
        if is_geographic:
            # --- MODIFICATION START: Halt execution for geographic CRS ---
            raise QgsProcessingException(
                self.tr("The input layer uses a geographic CRS (e.g., WGS 84). "
                        "This plugin requires a projected CRS for accurate calculations. "
                        "Please reproject your layer to a suitable projected CRS (e.g., UTM) and try again.")
            )
            # --- MODIFICATION END ---
        
        feedback.pushInfo("Projected CRS detected. Using layer units for calculation.")
        cell_width = self.parameterAsDouble(parameters, self.CELL_WIDTH, context)
        cell_height = self.parameterAsDouble(parameters, self.CELL_HEIGHT, context)
        calculation_crs = source_crs
        calc_extent = source.extent()

        feedback.pushInfo(f"Calculations will be performed in {calculation_crs.authid()}")

        fields = QgsFields()
        fields.append(QgsField('PageNumber', QVariant.Int))
        fields.append(QgsField('PageName', QVariant.String))
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context, fields, QgsWkbTypes.Polygon, source_crs)

        origin_x, origin_y = calc_extent.xMinimum(), calc_extent.yMinimum()
        num_rows = num_rows_override if num_rows_override > 0 else math.ceil(calc_extent.height() / cell_height)
        num_cols = num_cols_override if num_cols_override > 0 else math.ceil(calc_extent.width() / cell_width)
        feedback.pushInfo(f"Grid will have a maximum of {num_rows} rows and {num_cols} columns.")
        
        is_vector = isinstance(source, QgsVectorLayer)
        spatial_index = QgsSpatialIndex(source.getFeatures()) if is_vector else None
        
        page_counter = start_page

        def get_row_label(row_index, total_rows):
            is_top_down = (label_origin_index == 0 or label_origin_index == 1)
            effective_row = row_index if not is_top_down else (total_rows - 1) - row_index
            
            label = ""
            if effective_row < 0: return ""
            while True:
                label = chr(effective_row % 26 + 65) + label
                effective_row = effective_row // 26 - 1
                if effective_row < 0:
                    break
            return label

        r_iterator, c_iterator = None, None
        if label_origin_index == 0: # Top-Left
            r_iterator = range(num_rows - 1, -1, -1)
            c_iterator = range(num_cols)
        elif label_origin_index == 1: # Top-Right
            r_iterator = range(num_rows - 1, -1, -1)
            c_iterator = range(num_cols - 1, -1, -1)
        elif label_origin_index == 2: # Bottom-Left
            r_iterator = range(num_rows)
            c_iterator = range(num_cols)
        elif label_origin_index == 3: # Bottom-Right
            r_iterator = range(num_rows)
            c_iterator = range(num_cols - 1, -1, -1)
        
        row_counters = {}
        transform_to_source = QgsCoordinateTransform(calculation_crs, source_crs, context.transformContext())

        for r in r_iterator:
            for c in c_iterator:
                if feedback.isCanceled(): return {}
                
                cell_rect_calc = QgsRectangle(origin_x + (c * cell_width), 
                                            origin_y + (r * cell_height),
                                            origin_x + ((c + 1) * cell_width),
                                            origin_y + ((r + 1) * cell_height))
                
                cell_rect_source = transform_to_source.transform(cell_rect_calc) if is_geographic else cell_rect_calc
                
                found_intersection = False
                if is_vector:
                    if spatial_index.intersects(cell_rect_source):
                        for feat in source.getFeatures(QgsFeatureRequest().setFilterRect(cell_rect_source)):
                            if feat.geometry().intersects(cell_rect_source):
                                found_intersection = True
                                break
                else: # Raster
                    if source.extent().intersects(cell_rect_source):
                        found_intersection = True
                
                if found_intersection:
                    feat = QgsFeature(fields)
                    feat.setGeometry(QgsGeometry.fromRect(cell_rect_source))

                    row_letter = get_row_label(r, num_rows)
                    page_name = ""

                    if use_absolute_naming:
                        page_name = f"{row_letter}{c + 1}"
                    else:
                        if r not in row_counters:
                            row_counters[r] = 1 if c_iterator.start < c_iterator.stop else num_cols
                        
                        page_name = f"{row_letter}{row_counters[r]}"
                        
                        if c_iterator.start < c_iterator.stop:
                            row_counters[r] += 1
                        else:
                            row_counters[r] -= 1
                    
                    feat.setAttributes([page_counter, page_name])
                    
                    sink.addFeature(feat, QgsFeatureSink.FastInsert)
                    page_counter += 1

        return {self.OUTPUT: dest_id}

    def description(self):
        return self.tr(
            """
            <p>This algorithm creates a grid of rectangular polygon features for a map book index with advanced labeling controls.</p>
            <p><b>How it works:</b></p>
            <ol>
            <li>A grid is generated over the full extent of the selected <b>Intersection Layer</b>.</li>
            <li>Only grid cells that intersect with the Intersection Layer are kept in the final output.</li>
            </ol>
            <p><b><u>CRS & Unit Handling:</u></b></p>
            <p>This tool intelligently handles units. If your input layer has a geographic CRS (e.g., WGS 84), the tool automatically determines the best projected CRS for accurate, meter-based calculations. For projected layers, you can specify the cell size in any supported unit.</p>
            <p><b><u>Naming and Ordering:</u></b></p>
            <ul>
            <li><b>Use absolute grid position for Page Names:</b> When checked, the number in the name (e.g., the '5' in 'C5') corresponds to the grid's absolute column number. When unchecked, it's a sequential number for created cells within that row.</li>
            <li><b>Labeling starts from:</b> Controls which corner of the grid both the PageNumber and PageName sequences begin from.</li>
            </ul>
            """
        )

    def name(self):
        return 'Grid Index'
    def displayName(self):
        return self.tr(self.name())
    def group(self):
        return ''
    def groupId(self):
        return ''
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
    def createInstance(self):
        return gridindexAlgorithm()
    def icon(self):
        return QIcon(os.path.join(os.path.dirname(__file__), 'icon.png'))
